<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crash Dump Analyzer</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #0e1116; color: #e6edf3; }
        .topbar { position: sticky; top: 0; z-index: 100; background: #161b22; border-bottom: 1px solid #30363d; }
        .topbar-inner { width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; }
        .brand { font-weight: 700; color: #e6edf3; text-decoration: none; }
        .menu { display: flex; gap: 10px; align-items: center; margin-right: 24px; }
        .menu a { background: #1f2630; color: #e6edf3; border: 1px solid #30363d; padding: 6px 12px; border-radius: 6px; text-decoration: none; font-size: 14px; }
        .menu a:hover { background: #1b2230; }
        .upload-btn-header { background: #1f2630; color: #e6edf3; border: 1px solid #30363d; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: normal; }
        .upload-btn-header:hover { background: #1b2230; }

        .layout { max-width: 100vw; margin: 24px 0; padding: 0 12px; display: grid; grid-template-columns: 300px 1fr; gap: 16px; box-sizing: border-box; overflow: hidden; }
        
        /* Upload modal and button */
        .upload-btn { background: #238636; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; margin-bottom: 16px; width: 100%; font-weight: 500; }
        .upload-btn:hover { background: #2ea043; }
        .upload-btn:disabled { background: #484f58; cursor: not-allowed; }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); }
        .modal-content { background-color: #161b22; margin: 10% auto; padding: 20px; border: 1px solid #30363d; border-radius: 8px; width: 500px; max-width: 90%; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .modal-title { color: #e6edf3; font-size: 18px; font-weight: 600; margin: 0; }
        .close { color: #8b949e; font-size: 24px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #e6edf3; }
        
        .upload-area { padding: 40px 20px; border: 2px dashed #30363d; border-radius: 8px; text-align: center; background: #0d1117; transition: all 0.3s ease; cursor: pointer; margin-bottom: 20px; }
        .upload-area:hover, .upload-area.dragover { border-color: #0969da; background: #161b22; }
        .upload-area.uploading { border-color: #fb8500; background: #161b22; }
        .upload-area input[type="file"] { display: none; }
        .upload-button { background: #238636; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .upload-button:hover { background: #2ea043; }
        .upload-button:disabled { background: #484f58; cursor: not-allowed; }
        .upload-status { margin-top: 12px; color: #8b949e; font-size: 13px; }
        .upload-help { color: #8b949e; font-size: 12px; margin-top: 10px; }
        .panel { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; }
        h2 { margin: 0 0 12px 0; color: #e6edf3; }
        .muted { color: #8b949e; font-size: 13px; }
        
        /* Left panel - folder list */
        #list { list-style: none; padding: 0; margin: 8px 0 0 0; max-height: 70vh; overflow: auto; }
        #list li { margin: 4px 0; display: flex; flex-direction: column; align-items: flex-start; gap: 4px; padding: 8px 10px; border-radius: 6px; cursor: pointer; }
        #list li:hover { background: #1b2230; }
        #list li.active { background: #0d419d33; }
        .folder-name { color: #e6edf3; font-weight: 500; }
        .folder-info { font-size: 12px; color: #8b949e; }
        .file-indicators { display: flex; gap: 4px; margin-top: 4px; }
        .file-indicator { background: #30363d; color: #8b949e; padding: 2px 6px; border-radius: 3px; font-size: 11px; }
        .file-indicator.available { background: #1a7f37; color: #4ade80; }
        
        /* Status indicators */
        .status-indicator { 
            display: inline-flex; 
            align-items: center; 
            gap: 4px; 
            font-size: 11px; 
            padding: 4px 8px; 
            border-radius: 4px; 
            margin-top: 4px;
            font-weight: 500;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .status-indicator.pending { background: #fb8500; color: white; }
        .status-indicator.processing { background: #0969da; color: white; }
        .status-indicator.completed { background: #1a7f37; color: white; }
        .status-indicator.error { background: #da3633; color: white; }
        
        .spinner { width: 12px; height: 12px; border: 2px solid transparent; border-top: 2px solid currentColor; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Right panel - tabs and content */
        .viewer-panel { display: flex; flex-direction: column; min-width: 0; overflow: hidden; }
        .tabs { display: flex; background: #0d1117; border-bottom: 1px solid #30363d; border-radius: 8px 8px 0 0; }
        .tab { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; color: #8b949e; font-size: 14px; }
        .tab:hover { background: #161b22; color: #e6edf3; }
        .tab.active { color: #e6edf3; border-bottom-color: #0969da; background: #161b22; }
        .tab.disabled { color: #484f58; cursor: not-allowed; }
        .tab.disabled:hover { background: transparent; color: #484f58; }

        #viewer { background: #161b22; padding: 0; border: 1px solid #30363d; border-radius: 0 0 8px 8px; min-height: 400px; display: flex; flex-direction: column; min-width: 0; overflow: hidden; }
        .viewer-toolbar { display: flex; gap: 8px; align-items: center; justify-content: space-between; border-bottom: 1px solid #30363d; padding: 10px 12px; }
        .viewer-actions { display: flex; gap: 8px; }
        .viewer-actions a { background: #1f2630; color: #e6edf3; border: 1px solid #30363d; padding: 6px 10px; border-radius: 6px; text-decoration: none; cursor: pointer; font-size: 13px; }
        .viewer-actions a:hover { background: #1b2230; }
        .viewer-actions a[aria-disabled="true"] { background: #1f2630; color: #484f58; cursor: not-allowed; }
        .viewer-body { padding: 0; flex: 1; overflow: hidden; }
        .markdown-body { max-width: none; }
        .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { scroll-margin-top: 72px; }
        #viewer img { max-width: 100%; }
        
        /* Markdown content styling */
        .markdown-body { color: #e6edf3; }
        .markdown-body a { color: #58a6ff; text-decoration: none; }
        .markdown-body a:hover { color: #79c0ff; text-decoration: underline; }
        .markdown-body a:visited { color: #bc8cff; }
        .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { 
            color: #f0f6fc; 
            border-bottom: 1px solid #30363d; 
        }
        .markdown-body code { 
            background: #161b22; 
            color: #e6edf3; 
            padding: 2px 4px; 
            border-radius: 3px; 
            font-size: 0.9em; 
        }
        /* Reset to original GitHub markdown styling but ensure consistency */
        .markdown-body pre,
        .markdown-body pre[class*="language-"],
        .markdown-body .highlight pre,
        .markdown-body div[class*="highlight"] pre {
            background: #161b22 !important;
            border: 1px solid #30363d !important;
            border-radius: 6px !important;
            padding: 16px !important;
            margin: 16px 0 !important;
            overflow: auto !important;
        }
        .markdown-body pre code {
            background: transparent !important;
            color: #e6edf3 !important;
            padding: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            font-size: inherit !important;
        }
        .markdown-body pre code {
            background: transparent !important;
            color: #e6edf3 !important;
            padding: 0 !important;
            border-radius: 0 !important;
            font-size: inherit !important;
        }
        /* Override any Prism theme styles */
        .markdown-body .token.comment,
        .markdown-body .token.prolog,
        .markdown-body .token.doctype,
        .markdown-body .token.cdata { color: #8b949e !important; }
        .markdown-body .token.punctuation { color: #e6edf3 !important; }
        .markdown-body .token.property,
        .markdown-body .token.tag,
        .markdown-body .token.boolean,
        .markdown-body .token.number,
        .markdown-body .token.constant,
        .markdown-body .token.symbol,
        .markdown-body .token.deleted { color: #79c0ff !important; }
        .markdown-body .token.selector,
        .markdown-body .token.attr-name,
        .markdown-body .token.string,
        .markdown-body .token.char,
        .markdown-body .token.builtin,
        .markdown-body .token.inserted { color: #a5d6ff !important; }
        .markdown-body .token.operator,
        .markdown-body .token.entity,
        .markdown-body .token.url,
        .markdown-body .language-css .token.string,
        .markdown-body .style .token.string { color: #ff7b72 !important; }
        .markdown-body .token.atrule,
        .markdown-body .token.attr-value,
        .markdown-body .token.keyword { color: #d2a8ff !important; }
        .markdown-body .token.function,
        .markdown-body .token.class-name { color: #ffa657 !important; }
        .markdown-body blockquote { 
            border-left: 4px solid #30363d; 
            color: #8b949e; 
            margin: 0; 
            padding-left: 16px; 
        }
        .markdown-body table { 
            border-collapse: collapse; 
            border: 1px solid #30363d; 
        }
        .markdown-body th, .markdown-body td { 
            border: 1px solid #30363d; 
            padding: 8px 12px; 
        }
        .markdown-body th { 
            background: #161b22; 
            font-weight: 600; 
        }
        .markdown-body hr { 
            border: none; 
            border-top: 1px solid #30363d; 
            margin: 24px 0; 
        }

        /* Console/text content styling */
        .text-content { 
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
            font-size: 13px; 
            line-height: 1.5; 
            white-space: pre-wrap; 
            word-wrap: break-word;
            background: #0d1117; 
            padding: 16px; 
            border-radius: 6px; 
            overflow-y: auto; 
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            box-sizing: border-box;
        }
        
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
</head>
<body>
    <div class="topbar">
        <div class="topbar-inner">
            <a class="brand" href="index.html">Crash Dump Analyzer</a>
            <div class="menu">
                <button class="upload-btn-header" id="uploadBtn">📁 Upload Dumps</button>
            </div>
        </div>
    </div>

    <div class="layout">
        <div class="panel">
            <h2>Analysis Folders</h2>
            <div class="muted">Crash analysis packages</div>
            <ul id="list"></ul>
        </div>
        <div class="viewer-panel">
            <div class="tabs">
                <div class="tab active" data-type="analysis">Analysis Report</div>
                <div class="tab disabled" data-type="cdb_analyze">WinDbg Output</div>
                <div class="tab disabled" data-type="console">Console Log</div>
                <div class="tab disabled" data-type="dump">Dump File</div>
            </div>
            <div id="viewer" class="panel">
                <div class="viewer-toolbar">
                    <div class="muted" id="viewerTitle">Select an analysis folder to view its contents.</div>
                    <div class="viewer-actions">
                        <a id="openRaw" href="#" target="_blank" rel="noreferrer" aria-disabled="true">Open</a>
                        <a id="downloadRaw" href="#" download aria-disabled="true">Download</a>
                    </div>
                </div>
                <div class="viewer-body" id="viewerBody"></div>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Upload Crash Dump Files</h3>
                <span class="close" id="closeModal">&times;</span>
            </div>
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" accept=".dmp" multiple>
                <div id="uploadContent">
                    <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                        Choose Files
                    </button>
                    <div class="upload-status" id="uploadStatus">
                        Drop dump files here or click to select
                    </div>
                    <div class="upload-help">
                        Supports multiple .dmp files • Files will be processed one by one
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const listEl = document.getElementById('list');
        const viewer = document.getElementById('viewer');
        const viewerBody = document.getElementById('viewerBody');
        const viewerTitle = document.getElementById('viewerTitle');
        const openRawA = document.getElementById('openRaw');
        const downloadRawA = document.getElementById('downloadRaw');
        const tabs = document.querySelectorAll('.tab');

        let fullItems = [];
        let activeItem = null;
        let activeTab = 'analysis';
        let processingQueue = [];
        let currentlyProcessing = false;

        async function loadList() {
            try {
                const res = await fetch('analysis-list.aspx');
                const items = await res.json();
                fullItems = Array.isArray(items) ? items : [];
                renderList();
            } catch (e) {
                listEl.innerHTML = '<li class="muted">Failed to load list.</li>';
                viewerTitle.textContent = 'Select an analysis folder to view its contents.';
                viewerBody.innerHTML = '';
            }
        }

        function renderList() {
            let items = fullItems.slice();
            listEl.innerHTML = '';
            if (!items.length) {
                listEl.innerHTML = '<li class="muted">No analysis folders found.</li>';
                viewerTitle.textContent = 'Select an analysis folder to view its contents.';
                viewerBody.innerHTML = '';
                activeItem = null;
                setViewerActions(null);
                updateTabStates(null);
                return;
            }
            
            items.forEach(it => {
                const li = document.createElement('li');
                if (activeItem && activeItem.name === it.name) li.classList.add('active');
                li.addEventListener('click', () => { selectFolder(it); });
                
                const folderName = document.createElement('div');
                folderName.className = 'folder-name';
                folderName.textContent = it.name;
                
                const folderInfo = document.createElement('div');
                folderInfo.className = 'folder-info';
                folderInfo.textContent = it.modified;
                
                const indicators = document.createElement('div');
                indicators.className = 'file-indicators';
                
                // Show available files
                const fileTypes = ['analysis', 'cdb_analyze', 'console', 'dump'];
                fileTypes.forEach(type => {
                    const indicator = document.createElement('span');
                    indicator.className = 'file-indicator';
                    
                    if (it.files && it.files[type]) {
                        indicator.classList.add('available');
                        if (type === 'dump') {
                            indicator.textContent = 'dump';
                        } else if (type === 'cdb_analyze') {
                            indicator.textContent = 'windbg';
                        } else {
                            indicator.textContent = type;
                        }
                    } else {
                        if (type === 'dump') {
                            indicator.textContent = 'dump';
                        } else if (type === 'cdb_analyze') {
                            indicator.textContent = 'windbg';
                        } else {
                            indicator.textContent = type;
                        }
                    }
                    indicators.appendChild(indicator);
                });
                
                li.appendChild(folderName);
                li.appendChild(folderInfo);
                li.appendChild(indicators);
                listEl.appendChild(li);
            });

            // Auto-select first folder if none selected
            if (!activeItem && items.length > 0) {
                selectFolder(items[0]);
            }
        }

        function selectFolder(item) {
            activeItem = item;
            highlight(item);
            updateTabStates(item);
            // Don't call loadContent here - updateTabStates will handle it
        }

        function updateTabStates(item) {
            // Always find the best tab for this item, regardless of current state
            let targetTab = null;
            
            // Priority order for tab selection
            const tabPriority = ['analysis', 'cdb_analyze', 'console', 'dump'];
            
            // Find the first available tab in priority order
            for (const tabType of tabPriority) {
                if (item && item.files && item.files[tabType]) {
                    targetTab = tabType;
                    break;
                }
            }
            
            // Update tab disabled states
            tabs.forEach(tab => {
                const type = tab.dataset.type;
                const hasFile = item && item.files && item.files[type];
                tab.classList.toggle('disabled', !hasFile);
            });
            
            if (targetTab) {
                // Set the target tab as active
                activeTab = targetTab;
                tabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === activeTab);
                });
                loadContent(activeTab);
            } else {
                // No tabs available, clear content
                viewerBody.innerHTML = '<div style="padding: 16px;"><div class="muted">No content available for this analysis.</div></div>';
                viewerTitle.textContent = 'No content available';
                setViewerActions(null);
            }
        }

        function setActiveTab(type) {
            // Only switch if the tab is available for the current item
            if (activeItem && activeItem.files && activeItem.files[type]) {
                activeTab = type;
                tabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === type);
                });
                loadContent(type);
            } else {
                // Tab not available, show message
                viewerBody.innerHTML = '<div style="padding: 16px;"><div class="muted">This content is not available for this analysis.</div></div>';
                viewerTitle.textContent = 'Content not available';
                setViewerActions(null);
            }
        }

        async function loadContent(type) {
            if (!activeItem || !activeItem.files || !activeItem.files[type]) {
                viewerBody.innerHTML = '<div style="padding: 16px;"><div class="muted">File not available.</div></div>';
                viewerTitle.textContent = 'No content available';
                setViewerActions(null);
                return;
            }

            const fileInfo = activeItem.files[type];
            const fileName = type === 'dump' ? fileInfo.name : getFileDisplayName(type);
            
            viewerTitle.textContent = `${activeItem.name} - ${fileName}`;
            setViewerActions(fileInfo);

            try {
                if (type === 'dump') {
                    // For dump files, show file info with download button
                    viewerBody.innerHTML = `
                        <div style="padding: 24px;">
                            <h3 style="margin-top: 0; color: #e6edf3;">Dump File Information</h3>
                            
                            <div style="background: #0d1117; padding: 16px; border-radius: 6px; margin: 16px 0; font-family: 'Consolas', monospace;">
                                <div style="margin-bottom: 8px;"><strong>File:</strong> ${fileInfo.name}</div>
                                <div style="margin-bottom: 8px;"><strong>Size:</strong> ${formatBytes(fileInfo.size)}</div>
                                <div style="margin-bottom: 8px;"><strong>Modified:</strong> ${fileInfo.modified}</div>
                            </div>
                            
                            <p style="color: #8b949e; margin: 16px 0;">
                                This is a binary crash dump file that can be analyzed with WinDbg, Visual Studio, or other debugging tools.
                            </p>
                            
                            <div style="margin: 24px 0;">
                                <a href="${fileInfo.url}" download="${fileInfo.name}" 
                                   style="background: #238636; color: white; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-weight: 500; display: inline-flex; align-items: center; gap: 8px;">
                                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                                        <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                                    </svg>
                                    Download ${fileInfo.name}
                                </a>
                            </div>
                        </div>
                    `;
                } else {
                    const res = await fetch(fileInfo.url, { cache: 'no-cache' });
                    const content = await res.text();

                    if (type === 'analysis') {
                        // Render markdown
                        marked.setOptions({
                            gfm: true,
                            breaks: false,
                            headerIds: true,
                            mangle: false,
                            highlight: function(code, lang) {
                                try {
                                    // Ensure code blocks without explicit language still get highlighted
                                    var language = lang || 'clike'; // Default to 'clike' if no language is specified
                                    if (window.Prism && Prism.languages && Prism.languages[language]) {
                                        return Prism.highlight(code, Prism.languages[language], language);
                                    }
                                } catch (e) {
                                    console.log('Prism highlighting failed:', e);
                                }
                                return code;
                            },
                            langPrefix: 'language-', // Add language- prefix for Prism
                            headerPrefix: ''
                        });
                        viewerBody.innerHTML = '<div style="padding: 16px;"><div class="markdown-body">' + marked.parse(content) + '</div></div>';
                        // Trigger Prism highlighting after rendering
                        try {
                            if (window.Prism && Prism.highlightAllUnder) {
                                Prism.highlightAllUnder(viewerBody, true);
                            }
                        } catch (e) {
                            console.log('Prism post-highlighting failed:', e);
                        }
                        // Fix TOC links
                        try { fixTocAndHeadings(viewerBody); } catch (e) {}
                    } else {
                        // Show as plain text (console, cdb_analyze) with proper container
                        viewerBody.innerHTML = '<div style="height: 100%; display: flex; flex-direction: column; padding: 16px; box-sizing: border-box;"><div class="text-content">' + escapeHtml(content) + '</div></div>';
                    }
                }
            } catch (e) {
                viewerBody.innerHTML = '<div style="padding: 16px;"><div class="muted">Failed to load file.</div></div>';
            }
        }

        function highlight(item) {
            Array.from(listEl.children).forEach(li => li.classList.remove('active'));
            const nodes = Array.from(listEl.children);
            const idx = fullItems.findIndex(f => f.name === item.name);
            if (idx >= 0 && nodes[idx]) nodes[idx].classList.add('active');
        }

        function setViewerActions(fileInfo) {
            const disabled = !fileInfo;
            const isDumpFile = activeTab === 'dump';
            
            // For dump files, hide the toolbar buttons since we have a dedicated download button
            if (isDumpFile) {
                openRawA.style.display = 'none';
                downloadRawA.style.display = 'none';
                return;
            }
            
            // Show buttons for other file types
            openRawA.style.display = 'inline-block';
            downloadRawA.style.display = 'inline-block';
            
            openRawA.setAttribute('aria-disabled', disabled ? 'true' : 'false');
            downloadRawA.setAttribute('aria-disabled', disabled ? 'true' : 'false');
            if (!fileInfo) { 
                openRawA.removeAttribute('href'); 
                downloadRawA.removeAttribute('href'); 
                return; 
            }
            openRawA.href = fileInfo.url;
            downloadRawA.href = fileInfo.url;
        }

        function getFileDisplayName(type) {
            const names = {
                'analysis': 'analysis.md',
                'cdb_analyze': 'cdb_analyze.txt',
                'console': 'console.txt'
            };
            return names[type] || type;
        }

        function formatBytes(bytes) {
            const units = ['B','KB','MB','GB'];
            let i = 0; let n = bytes;
            while (n >= 1024 && i < units.length-1) { n /= 1024; i++; }
            return `${n.toFixed(1)} ${units[i]}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ---- TOC/Heading utilities ----
        function slugify(text) {
            return (text || '')
                .toLowerCase()
                .replace(/&amp;|&/g, 'and')
                .replace(/[^a-z0-9\s-_]/g, '')
                .trim()
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
        }

        function uniqueSlug(base, used) {
            if (!used[base]) { used[base] = 1; return base; }
            let i = used[base] + 1;
            let s = base + '-' + i;
            while (used[s]) { i++; s = base + '-' + i; }
            used[base] = i; used[s] = 1; return s;
        }

        function fixTocAndHeadings(container) {
            const used = {};
            const headings = container.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headings.forEach(h => {
                const base = slugify(h.textContent);
                const id = uniqueSlug(base || 'section', used);
                h.id = id;
            });
            const links = container.querySelectorAll('a[href^="#"]');
            links.forEach(a => {
                const href = (a.getAttribute('href') || '').slice(1);
                if (href && container.querySelector('#' + CSS.escape(href))) return;
                const guess = slugify(a.textContent);
                if (guess) a.setAttribute('href', '#' + guess);
            });
            // Smooth scroll accounting for sticky topbar
            container.addEventListener('click', function(e){
                const a = e.target.closest('a[href^="#"]');
                if (!a) return;
                const id = a.getAttribute('href').slice(1);
                const target = container.querySelector('#' + CSS.escape(id));
                if (target) {
                    e.preventDefault();
                    const top = target.getBoundingClientRect().top + window.scrollY - 72;
                    window.scrollTo({ top, behavior: 'smooth' });
                }
            });
        }

        // Modal functionality
        const uploadModal = document.getElementById('uploadModal');
        const uploadBtn = document.getElementById('uploadBtn');
        const closeModal = document.getElementById('closeModal');
        
        uploadBtn.addEventListener('click', () => {
            uploadModal.style.display = 'block';
        });
        
        closeModal.addEventListener('click', () => {
            uploadModal.style.display = 'none';
        });
        
        window.addEventListener('click', (e) => {
            if (e.target === uploadModal) {
                uploadModal.style.display = 'none';
            }
        });

        // Upload functionality
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');

        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.toLowerCase().endsWith('.dmp'));
            if (files.length > 0) {
                addFilesToQueue(files);
            }
        });

        // File input handler
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                addFilesToQueue(files);
                e.target.value = ''; // Reset input
            }
        });

        function addFilesToQueue(files) {
            files.forEach(file => {
                const queueItem = {
                    id: Date.now() + Math.random(),
                    file: file,
                    status: 'pending',
                    name: file.name.replace('.dmp', ''),
                    timestamp: new Date().toISOString().slice(0, 19).replace(/[:\-]/g, '').replace('T', '_')
                };
                processingQueue.push(queueItem);
                addPendingItemToList(queueItem);
            });
            
            if (!currentlyProcessing) {
                processQueue();
            }
            
            updateUploadStatus();
        }

        function addPendingItemToList(queueItem) {
            const li = document.createElement('li');
            li.id = 'pending-' + queueItem.id;
            li.style.opacity = '0.7';
            
            const folderName = document.createElement('div');
            folderName.className = 'folder-name';
            folderName.textContent = `dump_${queueItem.timestamp}`;
            
            const folderInfo = document.createElement('div');
            folderInfo.className = 'folder-info';
            folderInfo.textContent = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            const statusIndicator = document.createElement('div');
            statusIndicator.className = 'status-indicator pending';
            statusIndicator.innerHTML = '<span class="spinner"></span> Pending';
            
            li.appendChild(folderName);
            li.appendChild(folderInfo);
            li.appendChild(statusIndicator);
            
            // Add to top of list
            listEl.insertBefore(li, listEl.firstChild);
        }

        function updatePendingItemStatus(queueItem, status) {
            const li = document.getElementById('pending-' + queueItem.id);
            if (!li) return;
            
            const statusIndicator = li.querySelector('.status-indicator');
            statusIndicator.className = `status-indicator ${status}`;
            
            switch (status) {
                case 'processing':
                    statusIndicator.innerHTML = '<span class="spinner"></span> Analyzing';
                    break;
                case 'completed':
                    statusIndicator.innerHTML = '✓ Completed';
                    // Remove pending item after a delay
                    setTimeout(() => {
                        li.remove();
                        loadList(); // Refresh to show the completed analysis
                    }, 2000);
                    break;
                case 'error':
                    statusIndicator.innerHTML = '✗ Error';
                    setTimeout(() => li.remove(), 5000);
                    break;
            }
        }

        async function processQueue() {
            if (currentlyProcessing || processingQueue.length === 0) return;
            
            currentlyProcessing = true;
            const queueItem = processingQueue.shift();
            
            try {
                updatePendingItemStatus(queueItem, 'processing');
                await uploadAndAnalyze(queueItem);
                updatePendingItemStatus(queueItem, 'completed');
            } catch (error) {
                console.error('Analysis failed:', error);
                updatePendingItemStatus(queueItem, 'error');
            }
            
            currentlyProcessing = false;
            updateUploadStatus();
            
            // Process next item in queue
            if (processingQueue.length > 0) {
                setTimeout(() => processQueue(), 1000);
            }
        }

        async function uploadAndAnalyze(queueItem) {
            const formData = new FormData();
            formData.append('dumpFile', queueItem.file);
            
            const response = await fetch('upload.aspx', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Upload failed: ${response.status}`);
            }
            
            const result = await response.text();
            if (result.includes('ERROR') || result.includes('failed')) {
                throw new Error('Analysis failed');
            }
        }

        function updateUploadStatus() {
            const queueLength = processingQueue.length;
            const processing = currentlyProcessing;
            
            if (queueLength === 0 && !processing) {
                uploadStatus.textContent = 'Drop dump files here or click to select';
                uploadArea.classList.remove('uploading');
            } else if (processing) {
                uploadStatus.textContent = `Analyzing... ${queueLength} more in queue`;
                uploadArea.classList.add('uploading');
            } else {
                uploadStatus.textContent = `${queueLength} files in queue`;
                uploadArea.classList.remove('uploading');
            }
        }

        // Events - browser refresh handles page refresh
        
        // Tab click handlers
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                if (!tab.classList.contains('disabled')) {
                    const type = tab.dataset.type;
                    // Double-check that the content exists for the current item
                    if (activeItem && activeItem.files && activeItem.files[type]) {
                        setActiveTab(type);
                    }
                }
            });
        });

        loadList();
    </script>
</body>
</html>