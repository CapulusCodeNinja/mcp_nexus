<#
.SYNOPSIS
    Analyzes code coverage across all test projects and identifies areas needing improvement.

.DESCRIPTION
    This script aggregates coverage data from multiple Cobertura XML files generated by
    `dotnet test --collect:"XPlat Code Coverage"`. It provides comprehensive analysis including:
    - Classes with lowest branch coverage (below 75% threshold)
    - Classes with most missing branches (sorted by absolute count)
    - Overall solution-wide coverage statistics

    The script is designed to help developers identify testing gaps and prioritize
    coverage improvement efforts.

.PARAMETER CoveragePath
    Path to the directory containing coverage files. Defaults to '..\build\tests\TestResults'

.PARAMETER TopLowCoverage
    Number of classes to show in the "Lowest Branch Coverage" report. Default: 30

.PARAMETER TopMissingBranches
    Number of classes to show in the "Most Missing Branches" report. Default: 20

.PARAMETER MinBranchThreshold
    Minimum branch coverage threshold (%). Classes below this are highlighted. Default: 75

.EXAMPLE
    .\Analyze-AllCoverage.ps1
    
    Analyzes coverage using default parameters.

.EXAMPLE
    .\Analyze-AllCoverage.ps1 -TopLowCoverage 50 -MinBranchThreshold 80
    
    Shows top 50 classes with coverage below 80%.

.NOTES
    File Name      : Analyze-AllCoverage.ps1
    Prerequisite   : PowerShell 5.1 or later
    Usage          : Run after `dotnet test --collect:"XPlat Code Coverage"`
#>

param(
    [Parameter(Mandatory = $false)]
    [string]$CoveragePath = '..\build\tests\TestResults',

    [Parameter(Mandatory = $false)]
    [int]$TopLowCoverage = 30,

    [Parameter(Mandatory = $false)]
    [int]$TopMissingBranches = 20,

    [Parameter(Mandatory = $false)]
    [int]$MinBranchThreshold = 75
)

# ============================================================================
# STEP 1: Discover Coverage Files
# ============================================================================
# Search recursively for all Cobertura XML coverage files generated by dotnet test.
# Each test project generates its own coverage file.

Write-Host "`n[1/4] Discovering coverage files..." -ForegroundColor Cyan

$coverageFiles = Get-ChildItem -Path $CoveragePath -Filter 'coverage.cobertura.xml' -Recurse -ErrorAction SilentlyContinue

if ($null -eq $coverageFiles -or $coverageFiles.Count -eq 0) {
    Write-Host "ERROR: No coverage files found in '$CoveragePath'" -ForegroundColor Red
    Write-Host "TIP: Run 'dotnet test --collect:""XPlat Code Coverage""' first" -ForegroundColor Yellow
    exit 1
}

Write-Host "  Found $($coverageFiles.Count) coverage file(s)" -ForegroundColor Green

# ============================================================================
# STEP 2: Aggregate Coverage Data
# ============================================================================
# Parse each XML file and aggregate metrics by class.
# Multiple coverage files may contain data for the same class (due to partial classes
# or test project organization), so we sum all metrics for each unique class.

Write-Host "`n[2/4] Aggregating coverage data across projects..." -ForegroundColor Cyan

$allClasses = @{}
$fileCount = 0

foreach ($file in $coverageFiles) {
    $fileCount++
    Write-Host "  Processing file $fileCount/$($coverageFiles.Count): $($file.Name)" -ForegroundColor Gray
    
    try {
        [xml]$coverage = Get-Content $file.FullName
        
        # Navigate XML structure: coverage > packages > package > classes > class
        $coverage.coverage.packages.package | ForEach-Object {
            $packageName = $_.name
            
            $_.classes.class | ForEach-Object {
                # Create unique key: package.classname
                $fullClassName = "$packageName.$($_.name)"
                
                # Initialize class entry if first encounter
                if (-not $allClasses.ContainsKey($fullClassName)) {
                    $allClasses[$fullClassName] = @{
                        Package          = $packageName
                        Class            = $_.name.Split('.')[-1]  # Get last segment (simple class name)
                        FullName         = $_.name
                        LinesCovered     = 0
                        LinesValid       = 0
                        BranchesCovered  = 0
                        BranchesValid    = 0
                    }
                }
                
                # Aggregate coverage metrics (sum across all occurrences)
                $allClasses[$fullClassName].LinesCovered += [int]$_.'lines-covered'
                $allClasses[$fullClassName].LinesValid += [int]$_.'lines-valid'
                $allClasses[$fullClassName].BranchesCovered += [int]$_.'branches-covered'
                $allClasses[$fullClassName].BranchesValid += [int]$_.'branches-valid'
            }
        }
    }
    catch {
        Write-Host "  WARNING: Failed to parse $($file.FullName): $_" -ForegroundColor Yellow
    }
}

Write-Host "  Aggregated data for $($allClasses.Count) unique classes" -ForegroundColor Green

# ============================================================================
# STEP 3: Calculate Coverage Rates
# ============================================================================
# Transform raw metrics into percentage rates and prepare result objects.

Write-Host "`n[3/4] Calculating coverage rates..." -ForegroundColor Cyan

$results = $allClasses.Values | ForEach-Object {
    # Calculate line coverage rate (avoid division by zero)
    $lineRate = if ($_.LinesValid -gt 0) { 
        [math]::Round(($_.LinesCovered / $_.LinesValid) * 100, 1) 
    }
    else { 
        100.0  # No lines = 100% coverage (typically interfaces/empty classes)
    }
    
    # Calculate branch coverage rate (avoid division by zero)
    $branchRate = if ($_.BranchesValid -gt 0) { 
        [math]::Round(($_.BranchesCovered / $_.BranchesValid) * 100, 1) 
    }
    else { 
        100.0  # No branches = 100% coverage (no conditionals)
    }
    
    # Create result object with computed metrics
    [PSCustomObject]@{
        Package          = $_.Package
        Class            = $_.Class
        LineRate         = $lineRate
        BranchRate       = $branchRate
        BranchesTotal    = $_.BranchesValid
        BranchesCovered  = $_.BranchesCovered
        BranchesMissing  = $_.BranchesValid - $_.BranchesCovered
    }
}

# ============================================================================
# STEP 4: Generate Reports
# ============================================================================
# Display prioritized coverage gaps to guide testing efforts.

Write-Host "`n[4/4] Generating coverage reports..." -ForegroundColor Cyan

# Report 1: Classes with Lowest Branch Coverage (below threshold)
# Purpose: Identify poorly tested classes that need attention
Write-Host "`n=== Classes with Lowest Branch Coverage (below $MinBranchThreshold%) ===" -ForegroundColor Yellow
Write-Host "These classes have branches but low test coverage. Prioritize adding tests here.`n" -ForegroundColor Gray

$lowCoverageClasses = $results | 
    Where-Object { $_.BranchesTotal -gt 0 -and $_.BranchRate -lt $MinBranchThreshold } | 
    Sort-Object BranchRate, BranchesMissing -Descending | 
    Select-Object -First $TopLowCoverage

if ($lowCoverageClasses.Count -gt 0) {
    $lowCoverageClasses | Format-Table Package, Class, BranchRate, BranchesCovered, BranchesTotal, BranchesMissing -AutoSize
}
else {
    Write-Host "  ✓ All classes meet the $MinBranchThreshold% branch coverage threshold!" -ForegroundColor Green
}

# Report 2: Classes with Most Missing Branches (absolute count)
# Purpose: Find classes where adding tests will have biggest coverage impact
Write-Host "`n=== Classes with Most Missing Branches ===" -ForegroundColor Red
Write-Host "Adding tests for these classes will have the biggest impact on overall coverage.`n" -ForegroundColor Gray

$results | 
    Where-Object { $_.BranchesTotal -gt 0 } | 
    Sort-Object BranchesMissing -Descending | 
    Select-Object -First $TopMissingBranches | 
    Format-Table Package, Class, BranchRate, BranchesCovered, BranchesTotal, BranchesMissing -AutoSize

# Report 3: Overall Statistics
# Purpose: Track solution-wide coverage progress
Write-Host "`n=== Overall Solution Coverage ===" -ForegroundColor Cyan

$totalLinesCovered = ($allClasses.Values | Measure-Object -Property LinesCovered -Sum).Sum
$totalLinesValid = ($allClasses.Values | Measure-Object -Property LinesValid -Sum).Sum
$totalBranchesCovered = ($allClasses.Values | Measure-Object -Property BranchesCovered -Sum).Sum
$totalBranchesValid = ($allClasses.Values | Measure-Object -Property BranchesValid -Sum).Sum

$overallLineRate = [math]::Round(($totalLinesCovered / $totalLinesValid) * 100, 1)
$overallBranchRate = [math]::Round(($totalBranchesCovered / $totalBranchesValid) * 100, 1)
$branchesMissing = $totalBranchesValid - $totalBranchesCovered

# Format output with status indicators
$lineStatus = if ($overallLineRate -ge 75) { "✓" } else { "✗" }
$branchStatus = if ($overallBranchRate -ge 75) { "✓" } else { "✗" }

Write-Host "  $lineStatus Line Coverage:   $overallLineRate% ($totalLinesCovered / $totalLinesValid)" -ForegroundColor $(if ($overallLineRate -ge 75) { "Green" } else { "Yellow" })
Write-Host "  $branchStatus Branch Coverage: $overallBranchRate% ($totalBranchesCovered / $totalBranchesValid)" -ForegroundColor $(if ($overallBranchRate -ge 75) { "Green" } else { "Yellow" })
Write-Host "  Branches Missing: $branchesMissing" -ForegroundColor Gray

Write-Host "`n✓ Analysis complete!`n" -ForegroundColor Green



